--- a/dbus/dbus.go
+++ b/dbus/dbus.go
@@ -47,22 +47,28 @@ type mgrState struct {
 	sigref map[string]uint64
 }
 
+func mkSignalKey(iface, member string) string {
+	return iface + "." + member
+}
+
 func (s *mgrState) AddMatchSignal(conn *dbus.Conn, iface, member string) {
 	// Only register for signal if not already registered
-	if s.sigref[iface+"."+member] == 0 {
+	key := mkSignalKey(iface, member)
+	if s.sigref[key] == 0 {
 		conn.BusObject().Call(fdtAddMatch, 0,
 			"type='signal',interface='"+iface+"',member='"+member+"'")
 	}
-	s.sigref[iface+"."+member]++
+	s.sigref[key]++
 }
 
 func (s *mgrState) RemoveMatchSignal(conn *dbus.Conn, iface, member string) {
 	// Only deregister if this is the last request
-	if s.sigref[iface+":"+member] == 0 {
+	key := mkSignalKey(iface, member)
+	if s.sigref[key] == 0 {
 		return
 	}
-	s.sigref[iface+":"+member]--
-	if s.sigref[iface+"."+member] == 0 {
+	s.sigref[key]--
+	if s.sigref[key] == 0 {
 		conn.BusObject().Call(fdtRemoveMatch, 0,
 			"type='signal',interface='"+iface+"',member='"+member+"'")
 	}
@@ -265,14 +271,16 @@ type Object struct {
 	emitterm   multiWriterValue
 	objects    multiWriterValue
 	bus        *BusManager
+	parent     *Object
 }
 
-func NewObject(name string, value interface{}, s seriatim.Supervisor, bus *BusManager) *Object {
+func NewObject(name string, value interface{}, parent *Object, bus *BusManager) *Object {
 	obj := &Object{
 		name:    name,
 		value:   reflect.ValueOf(value),
-		sequent: seriatim.NewSupervisedSequent(value, s),
+		sequent: seriatim.NewSupervisedSequent(value, parent),
 		bus:     bus,
+		parent:  parent,
 	}
 	obj.interfaces.Store(make(map[string]*Interface))
 	obj.listeners.Store(make(map[string]*Interface))
@@ -282,18 +290,42 @@ func NewObject(name string, value interf
 	return obj
 }
 
+func (o *Object) removeListeners() {
+	o.listeners.Update(func(value *atomic.Value) {
+		for dbusIfaceName, intf := range value.Load().(map[string]*Interface) {
+			println("SequentTerm: handling interface", dbusIfaceName)
+			for sigName, _ := range intf.signals {
+				println("SequentTerm: handling signal", sigName)
+				o.bus.state.Call("RemoveMatchSignal", o.bus.conn,
+					dbusIfaceName, sigName)
+			}
+		}
+		value.Store(make(map[string]*Interface))
+	})
+}
+
 func (o *Object) SequentTerminated(reason error, id uintptr) {
 	o.objects.Update(func(value *atomic.Value) {
 		objects := make(map[string]*Object)
 		for name, obj := range value.Load().(map[string]*Object) {
-			if obj.sequent.Id() == id {
-				//TODO: preserve children
-				continue
+			if obj.hasActions() && obj.sequent.Id() == id {
+				obj.removeListeners()
+				// if there are children replace with placeholder
+				if obj.hasChildren() {
+					object := NewObject(name, nil, o, o.bus)
+					object.objects = obj.objects
+					obj = object
+				} else {
+					continue
+				}
 			}
 			objects[name] = obj
 		}
 		value.Store(objects)
 	})
+	if !o.hasActions() && o.parent != nil {
+		o.parent.rmChildObject(o.name)
+	}
 }
 
 func (o *Object) getObjects() map[string]*Object {
@@ -304,6 +336,10 @@ func (o *Object) getInterfaces() map[str
 	return o.interfaces.Load().(map[string]*Interface)
 }
 
+func (o *Object) getListeners() map[string]*Interface {
+	return o.listeners.Load().(map[string]*Interface)
+}
+
 func (o *Object) newObject(path []string, val interface{}) *Object {
 	name := path[0]
 	switch len(path) {
@@ -315,7 +351,7 @@ func (o *Object) newObject(path []string
 		obj, ok := o.LookupObject(name)
 		if !ok {
 			//placeholder object for introspection
-			obj = NewObject(name, nil, nil, o.bus)
+			obj = NewObject(name, nil, o, o.bus)
 			o.addObject(name, obj)
 		}
 		return obj.newObject(path[1:], val)
@@ -333,7 +369,16 @@ func (o *Object) NewObject(path dbus.Obj
 	return o.newObject(ps, val)
 }
 
+func (o *Object) hasActions() bool {
+	return o.sequent != nil
+}
+
+func (o *Object) hasChildren() bool {
+	return len(o.getObjects()) > 0
+}
+
 func (o *Object) terminate() {
+	println("terminate", o.name)
 	if o.sequent != nil {
 		o.sequent.Terminate(nil)
 	}
@@ -346,18 +391,23 @@ func (o *Object) rmChildObject(name stri
 			objects[child] = obj
 		}
 		if obj, ok := objects[name]; ok {
-			// if there are children replace with placeholder
-			if len(obj.getObjects()) > 0 {
-				object := NewObject(name, nil, nil, o.bus)
-				object.objects = obj.objects
-				objects[name] = object
-			} else {
-				delete(objects, name)
-			}
 			obj.terminate()
+			if !obj.hasActions() {
+				// if there are children replace with placeholder
+				if obj.hasChildren() {
+					object := NewObject(name, nil, o, o.bus)
+					object.objects = obj.objects
+					obj = object
+				} else {
+					delete(objects, name)
+				}
+			}
 		}
 		value.Store(objects)
 	})
+	if !o.hasActions() && o.parent != nil {
+		o.parent.rmChildObject(o.name)
+	}
 }
 
 func (o *Object) delObject(path []string) {
@@ -423,6 +473,7 @@ func (o *Object) addInterface(name strin
 }
 
 func (o *Object) addListener(name string, iface *Interface) {
+	println("addListener:", o.name)
 	o.listeners.Update(func(value *atomic.Value) {
 		listeners := make(map[string]*Interface)
 		for name, intf := range value.Load().(map[string]*Interface) {
@@ -604,7 +655,7 @@ func (o *Object) Receives(
 
 // Deliver the signal to this object's listeners and all child objects
 func (o *Object) DeliverSignal(iface, member string, signal *dbus.Signal) {
-	listeners := o.listeners.Load().(map[string]*Interface)
+	listeners := o.getListeners()
 	for sigiface, intf := range listeners {
 		if iface != sigiface {
 			continue
@@ -617,7 +668,7 @@ func (o *Object) DeliverSignal(iface, me
 		}
 	}
 
-	objects := o.objects.Load().(map[string]*Object)
+	objects := o.getObjects()
 	for _, obj := range objects {
 		obj.DeliverSignal(iface, member, signal)
 	}
